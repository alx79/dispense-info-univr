\documentclass[a4paper, 10pt]{article}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\hypersetup{
	hidelinks, 
	colorlinks = true,
	linkcolor = black
}
\usepackage{pgf-umlcd}
\usepackage{tikz}
\usetikzlibrary{patterns}
\usepackage{frontespizio}
\usetikzlibrary{shapes,positioning,calc}
\usetikzlibrary{shapes.geometric, arrows}
\usetikzlibrary{arrows.meta}
\usepackage{geometry}
\geometry{a4paper, left=3cm,right=3cm,top=3cm,bottom=3cm}

\renewcommand{\umltextcolor}{black}
\renewcommand{\umldrawcolor}{black}
\renewcommand{\umlfillcolor}{white}


\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\nouppercase{\leftmark}}
\rhead{\nouppercase{\rightmark}}
\chead{}
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\tikzstyle{box} = [rectangle, 
rounded corners, minimum width=2.6cm, minimum height=1cm,text centered, draw=black]

\begin{document}
	\begin{frontespizio}
		\Universita{di Verona}
		\Facolta{Scienze e Ingegneria}
		\Corso[Laurea]{Informatica}
		\Annoaccademico{2016/2017}
		\Titolo{Ingegneria del Software}
		\Sottotitolo{Riassunto dei principali argomenti}
		\NCandidati{Autori}
		\Candidato[]{Davide Bianchi}
		\Candidato[]{Matteo Danzi}
	\end{frontespizio}
	\tableofcontents
	
	\newpage
	
	\section{Introduzione}
	L' ingegneria del software è lo \textit{studio delle metodologie, strumenti e teorie che
		stanno alla base della creazione dei software a livello professionale}.
	
	\noindent
	È lo studio a livello \textit{professionale} perché a livello \textit{artigianale} non sempre vi è la garanzia del prodotto, in quanto non è garantito che la soluzione sia \textbf{scalabile} (cioè
	permette di utilizzare il software per un ambito/problema più grande o differente rispetto a quello in cui è utilizzato).\\
	I prodotti software si suddividono in:
	\begin{itemize}
		\item \textbf{prodotti software generici} (e.g.: S.O., Applicazioni ...)
		
		prodotti in cui il progettista decide le caratteristiche del prodotto e deve accontentare le richieste da parte di molti utenti cercando di creare un progetto generico diretto a  una vasta categoria di persone.
		\item \textbf{prodotti software specifici/personalizzati}(e.g.: Applicativi per monitorare l'inquinamento)
		
		prodotti in cui l'utilizzatore richiede al progettista le caratteristiche che deve avere il prodotto, e il software è pesantemente influenzato da chi lo usa.
	\end{itemize}
	
	\noindent
	\textbf{Ma che cos'è il software?} 
	
	\noindent
	Il software non è altro che un insieme di programmi che svolgono un compito qualsiasi e che viene opportunamente documentato, la cui documentazione indica com'è strutturato. \\
	
	\noindent
	\subsection{Caratteristiche di un buon prodotto software}
	\begin{enumerate}
		\item \textbf{Mantenibilità}: 
		\begin{itemize}
			\item deve poter essere gestito su un periodo vita medio/lungo.
			\item deve saper gestire eventuali errori che non si erano trovati precedentemente.
			\item deve fare in modo che il software giri su piattaforme diverse.
		\end{itemize}
		\item \textbf{Affidabilità}: un software deve eseguire quello che gli viene imposto senza
		compromettere altri aspetti come ad esempio la sicurezza degli utenti.
		\item \textbf{Usabilità}: quanto è facile da utilizzare un software, saperlo utilizzare senza dover leggere le istruzioni. Ad esempio per utilizzare un browser web utilizzo sempre gli stessi criteri di usabilità e faccio in modo che sia utilizzabile in modo intuitivo.
	\end{enumerate}
	
	
	\noindent
	\subsection{Quattro attività principali dell' ingegneria del software}
	\begin{enumerate}
		\item \textbf{\textit{Specifica del software}} : si considerano i requisiti di chi mi richiede di
		creare il software.
		\subitem{-} l'ingegneria dei requisiti considera i requisti dati e li trasforma in
		requisiti ad alto livello, ma più rigorosi e meno ambigui.
		\item \textbf{\textit{Realizzazione del software}} : si appoggia sui requisiti e consiste di due fasi:
		\subitem{-} progettazione
		\subitem{-} implementazione
		\item \textbf{\textit{Validazione del software}} : è un fattore molto importante e consiste nella
		validazione da parte di un utente del software creato.
		\item \textbf{\textit{Evoluzione del software}} : consiste in modifiche e aggiornamenti apportati
		dopo la creazione finale del software; rappresenta il costo principale
		(più del 50\%!!!) di una vita media di un sw.
		
	\subsection*{Problemi e sfde attuali dell' ingegneria del software}
		
		\begin{itemize}
			\item \underline{sicurezza}: privacy, frodi, danni a cose o persone ecc.
			\item \underline{costi}: si deve contenere i costi di produzione sotto controllo.
			\item \underline{etereogeneità}: sfruttare il sw su più macchine, soddisfare più richieste in
			contemporanea ecc.
			\item \underline{tempistiche}: sono sempre più ridotte.
		\end{itemize}
		
	\subsection{Efficienza VS efficacia}
		L' \textit{efficienza} indica quanto materiale uso per risolvere un problema, è un'aspetto più computazionale, mentre l' \textit{efficacia} consiste nel chiedersi se un sw svolge il proprio compito per cui è stato creato, quanto un sw è in grado di risolvere il problema richiesto dall'utente e quindi se raggiunge l'obbiettivo delle specifiche.
		
		\noindent
		Tipologie software:
		\begin{enumerate}
			\item \underline{Sistemi Stand-Alone}: sistemi sw isolati a livello di rete, funzionano su una macchina isolata.
			\item \underline{Applicazioni interattive basate su transizioni}: scambio di dati concordato
			da entrambe le parti (vi è il concetto di "o tutto, o niente"). Sono per lo
			più basate sul web e quindi distribuite sulla rete. Ad esempio operazioni di scambio di dati tipo commercio elettronico(Amazon) oppure tutte le applicazioni bancarie.
			\item \underline{Sistemi embedded}: sistemi sw che sono innestati all'interno di apparecchi di varia natura (controllo treni, bancomat). Il software è a bordo di un sistema dedicato e quindi ho vincoli architetturali. 
			\item \underline{Applicazioni batch}: applicazioni che elaborano dati in grossi gruppi. Ad esempio stampare e produrre dati bancari di tutti i clienti di una banca in un certo istante oppure inserimento pesante di dati.
			\item \underline{Sistemi d'intrattenimento}: tipo videogiochi, film on demand, il daltonismo del Dalty ecc. Pesantemente basati sul web.
			\item \underline{Applicazioni di raccolta dati}: tipo Arpav, centraline per rilevare dati di inquinamento, i quali vengono raccolti e compongono un archivio.\underline{Wearable Systems}: cioè sistemi che raccolgono parametri vitali (tipo elettrocardiogramma, per monitorare ...).
			\item \underline{Sistemi di sistemi}: sistemi che si basano su altri sistemi
			
			esempio: Amazon che ha una parte basata su transazioni, che gestisce i pagamenti, e una parte di applicazione raccolta dati, che permette di avere informazioni sui clienti per dare consigli e pubblicità (cookies, banner...).
		\end{enumerate}
	\end{enumerate}
		
	\subsection{Fondamenti dell'ingegneria del Software}
		Ogni sviluppo del SW dovrebbe avere:
		\begin{itemize}
			\item Chiara metodologia/processo di sviluppo:
			\begin{itemize}
				\item devo avere un percorso ben definito all'inizio
				\item devo dotarmi di strumenti che mi supportano le fasi di sviluppo
				\item devo sapere come avvengono i vari passi di sviluppo
			\end{itemize}
			\item Affidabilità e prestazioni (Efficienza-Efficacia)
			\item Specifica del Software e requisiti
			\item Riuso del Software: esistono componenti SW che permettono di iniziare a costruire un nuovo progetto prendendo questi esempi e usando le \textit{librerie di base}.
		\end{itemize}
		
	\section{Etica dell'ingegneria del Software}
		Gli ingegneri del software devono devono comportarsi in modo onesto e in modo eticamente responsabile se vogliono essere rispettati dal punto di vista professionale. Il comportamento etico non è solamente il semplice rispetto della legge ma implica il rispetto di un insieme di principi che sono moralmente corretti.
		\begin{itemize}
			\item \textbf{Confidenzialità}: Gli ingegneri dovrebbero rispettare la confidenzialità dei loro datori di lavoro o clienti, indipendentemente dal fatto che si sia firmato un accordo di confidenzialità.
			\item \textbf{Competenza-Onestà}: Gli sviluppatori non dovrebbero fornire false competenze o accettare lavori che sono al di là del proprio livello di conoscenza. Dovrebbero invece costantemente documentarsi e aggiornare le proprie competenze se il lavoro che devono svolgere lo richiede.
			\item \textbf{Proprietà Intellettuale}: Gli ingegneri dovrebbero essere a conoscenza delle leggi che governano l'uso della proprietà intellettuale, come ad esempio brevetti, licenze, copyright, ecc. Dovrebbero fare in modo di assicurare che la proprietà intellettuale dei dipendenti o dei clienti sia protetta.
			\item \textbf{Uso Scorretto del SW}: Gli ingegneri del software non dovrebbero usare le loro conoscenze tecniche per danneggiare gli altri. Non possono usare il software in modo ricreativo (giocare a videogiochi sui pc dei dipendenti) oppure malevolo (generare virus), devono generare software senza arrecare danni. 
			\item \textbf{Giudizio e Rapporto con colleghi}: Gli ingegneri del sw dovrebbero essere giusti e coadiuvare in modo corretto i propri colleghi, se necessario.
		\end{itemize}
		 Le organizzazioni statunitensi \textit{ACM/IEEE} hanno cooperato per costruire un codice etico, che viene firmato dai membri di queste quando vengono assunti. Il codice contiene 8 princìpi legati al comportamento e alle decisioni fatte dagli ingegneri del software professionisti, includendo anche altre professioni (manager, insegnanti, medici ...).
		 
		\subsection{Dilemmi Etici}
			Esempi di dilemmi etici e relative ipotetiche soluzioni:
			\begin{itemize}
				\item Disaccordo con i principi e con le politiche aziendali.
				
				Soluzione: proposta di una soluzione alternativa corretta dal punto di vista etico
				
				\item I dipendenti non si comportano in modo responsabile ed eticamente scorretto pubblicando sistemi non stabili dal punto di vista della sicurezza, senza eseguire gli adeguati test sul software.
				
				Soluzione: Devo garantire il controllo sui dipendenti per migliorare la qualità e la professionalità.
			\end{itemize}
			
	\section{Processi per lo sviluppo di Software}
		I processi per il Software sono l'insieme strutturato di attività richieste per sviluppare un sistema software. Ci sono molti modelli di processo diversi, cioè molti diversi schemi per realizzare sw utilizzabili per molte diverse tipologie. Tutti questi modelli comprendono:
			\begin{enumerate}
				\item Specifica: cosa il sistema dovrebbe fare.
				\item Progettazione e Implementazione: definire l'organizzazione del sistema e l'implementazione dello stesso.
				\item Validazione: controllare che faccia ciò che il cliente vuole.
				\item Evoluzione: cambiare il sistema in risposta ai cambiamenti di ciò che il cliente vuole.
			\end{enumerate}
	Un modello di processo per il software è una rappresentazione astratta di un processo. Presenta una descrizione di un processo da uno specifico punto di vista.
	
	\noindent
	Quando si descrivono i processi solitamente si parla di attività come ad esempio la specifica di strutture dati, la costruzione di un'interfaccia utente, ecc. e l'ordinamento di tali attività.
	
		\subsection{Processi Plan-driven e Agile}
			Nei processi \textbf{plan-driven} tutte le attività vengono pianificate all'inizio e mentre si esegue lo sviluppo viene verificata la progressione dell'esecuzione del piano iniziale.
			
			\noindent
			Nei processi \textbf{agile} la pianificazione viene fuori man mano che le attività vengono eseguite e quindi risulta più facile modificare il processo a fronte del cambiamento delle richieste da parte del cliente.
			
			\noindent
			Nella pratica la maggior parte dei processi pratici include sia elementi dell'uno che dell'altro approccio.
			
		\subsection{Modelli di processi Software}
			Ci sono 3 tipi di modelli di processi software:
			\subsubsection{Modello a cascata}
				
				Modello \textit{Plan-driven} in cui le fasi di specifica e di sviluppo sono distinte e separate.
				
				\begin{tikzpicture}[>=latex, baseline= 25pt]
					\node[box, align=center] (a) at (0,0) {Definizione dei Requisiti};
					\node[box, align=center] (b) at (2,-1) {Progettazione SW\\e del Sistema};
					\node[box, align=center] (c) at (4,-2) {Implementazione\\e test su unità};
					\node[box, align=center] (d) at (6,-3) {Integrazione\\e validazione sistema};
					\node[box, align=center] (e) at (8,-4) {Operatività e gestione};
					
					\draw[->] (a.east) -- (2.5,0) -- (2.5, -0.5);
					\draw[->] (b.east) -- (4,-1) -- (c.north);
					\draw[->] (c.east) -- (6,-2) -- (d.north);
					\draw[->] (d.east) -- (8,-3) -- (e.north);
					\draw[->] (e.south) -- (8,-5) -- (0,-5) -- (a.south);
					\draw[->] (2,-5) -- (b.south);
					\draw[->] (4,-5) -- (c.south);
					\draw[->] (6,-5) -- (d.south);
					
				\end{tikzpicture}
				
				\vspace*{0.5cm}
				
				\noindent
				L'output diventa input, ogni fase non inizia prima che la precedente sia terminata. Solo quando arrivo all'ultima fase ho \textit{retroazione} e posso tornare indietro.
				
				\noindent
				Lo \textbf{svantaggio} principale è la difficoltà di cambiamento dopo che il processo si è avviato.
				La sua partizione in fasi distinte rende difficile rispondere ai cambiamenti delle specifiche da parte del cliente. Questo modello è appropriato quando i requisiti sono stati ben compresi e i cambiamenti saranno limitati durante il processo di sviluppo.
				
				Questo modello è principalmente usato per grossi progetti di sistemi di ingegneria dove un sistema è sviluppato in diverse zone.
				
			\subsubsection{Sviluppo incrementale}
			\begin{center}
			\begin{tikzpicture}[>=latex]
				\node[box, align=center] (a) at (0,-1.5) {Descrizione\\ del problema};
				\node[box] (b) at (4,0) {Specifica};
				\node[box] (c) at (4,-1.5) {Sviluppo};
				\node[box] (d) at (4,-3) {Validazione};
				\node[box, rounded corners=false] (e) at (8,-0) {Versione Iniziale};
				\node[box, align=center, rounded corners=false] (f) at (8,-1.5) {Versioni\\ Intermedie};
				\node[box, rounded corners=false] (g) at (8,-3) {Versione Finale};
				
				\draw[dashed, rounded corners] (2,1) rectangle (6,-4); 
				\node[below] at (4,-4) {Attività Concorrenti};
				
				\draw[->] (a.east) -- (c.west);
				\draw[->] ($(b.south) +(0.2,0)$) -- ($(c.north) +(0.2,0)$);
				\draw[<-] ($(b.south) -(0.2,0)$) -- ($(c.north) -(0.2,0)$);
				\draw[->] ($(c.south) +(0.2,0)$) -- ($(d.north) +(0.2,0)$);
				\draw[<-] ($(c.south) -(0.2,0)$) -- ($(d.north) -(0.2,0)$);
				\draw[->] ($(b.east) +(0,0.2)$) -- ($(e.west) +(0,0.2)$);
				\draw[<-] ($(b.east) -(0,0.2)$) -- ($(e.west) -(0,0.2)$);
				\draw[->] ($(c.east) +(0,0.2)$) -- ($(f.west) +(0,0.2)$);
				\draw[<-] ($(c.east) -(0,0.2)$) -- ($(f.west) -(0,0.2)$);
				\draw[->] (d.east) -- (g.west);
			\end{tikzpicture}
			\end{center}
			Le fasi di Specifica, Sviluppo e Valutazione sono concorrenti e non è detto che avvengano sempre nell'ordine se ho diverse parti di un progetto. Fornisce risultati intermedi che vengono raffinati sulla base del confronto con l'utente il quale rimane coinvolto in tutto il processo. Può essere \textit{plan-driven} e quindi fisso il numero di prodotti intermedi, altrimenti è \textit{agile}.
			
			\noindent
			\textbf{Vantaggi}:
			\begin{itemize}
				\item Se i requisiti non sono chiari o vengono cambiati durante la costruzione, posso modificare a run-time gestendo dinamicamente gli aggiornamenti e riducendo quindi il costo.
				La quantità di documentazione che deve essere rifatta è molto inferiore rispetto al modello a cascata.
				
				\item Ho un maggior coinvolgimento del committente il quale riesce a vedere in modo periodico gli sviluppi del progetto e riesce a modificarlo eventualmente.
				
				\item Ho una consegna di software utile più rapida al committente.
			\end{itemize}
			
			\noindent
			\textbf{Svantaggi}:
			\begin{itemize}
				\item Il processo non è così visibile come nel modello a cascata. Documento le parti più importanti senza mostrare i cambiamenti. Si hanno quindi fasi intermedie prive di documentazione.
				
				\item L'idea di aggiungere parti ad un software produce un degrado del software. Non è più così efficiente e organico come si era pensato inizialmente. Bisogna quindi riorganizzare il software raffinandolo per evitare il peggioramento dell'efficienza; questo però aggiunge costi ulteriori.
			\end{itemize}
			
			\subsubsection{Processi basati sul riuso}
			I sistemi non vengono ricreati da zero, bensì vengono riciclati da componenti già esistenti o da applicazioni COTS (commercial-off-the-shelf systems). Gli elementi riusati possono essere riconfigurati per adattare le loro funzionalità alle richieste dei committenti.
			È l'approccio standard per costruire la maggior parte dei sistemi commerciali.
			
			\begin{tikzpicture}[>=latex, baseline=0.5cm, scale=0.8,every node/.style={scale=0.8}]
			\node[box,align=center] (a) at (0,0) {Specifica\\ dei Requisiti};
			\node[box,align=center] (b) at (3.5,0) {Analisi\\ dei Componenti};
			\node[box,align=center] (c) at (7,0) {Modifica\\ dei Requisiti};
			\node[box,align=center] (d) at (10.5,0) {Progettazione\\ con Riuso};
			\node[box,align=center] (e) at (14,0) {Sviluppo\\ e Integrazione};
			\node[box,align=center] (f) at (14,-2) {Validazione};
			\node[align=center] (g) at (10.5,-1.5) {Per ogni\\ componente};
			\node[align=center] (h) at (10.5,-2.5) {Totale};
			
			\draw[->] (a.east) -- (b.west);
			\draw[->] (b.east) -- (c.west);
			\draw[->] (c.east) -- (d.west);
			\draw[->] (d.east) -- (e.west);
			\draw[->] (e.south) -- (f.north);
			\draw[->] (f.west) -- (g.east);
			\draw[->] (f.west) -- (h.east);
			
			\end{tikzpicture}
			
			\vspace*{0.2cm}
			\textbf{Vantaggi e svantaggi}:
			\begin{itemize}
				\item Si riducono i costi e i rischi poiché meno software è sviluppato da zero.
				\item Consegna e pubblicazione dei sistemi avviene in modo più veloce.
				\item Compromessi sulle specifiche sono inevitabili, quindi i sistemi potrebbero non soddisfare pienamente i reali bisogni dei committenti.
				\item Perdita di controllo sull'evoluzione degli elementi del sistema riusati.
			\end{itemize}
			
		\subsection{Attività dei processi}
		
		\subsubsection{Specifica del software}
		La specifica comprende 4 fasi principali:
		\begin{enumerate}
			\item \textbf{Studio di fattibilità}: quali costi e quali risorse/competenze bisogna avere per specificare il software. Si sviluppa un modello che simula i costi e si ricava una stima del costo.
			
			\item \textbf{Elicitazione(estrazione) e analisi dei requisiti}: si analizza ciò che l'utente utilizza normalmente per estrarre informazione e per fondare le parti del software. Questa fase comprende anche l'intervista di utenti, i quali possono avere attese e esigenze diverse.
			
			\item \textbf{Specifica dei requisiti}: si utilizzano formalismi diagrammatici per definire e rappresentare i requisiti.
			
			\item \textbf{Validazione dei requisiti}
			
		\end{enumerate}
			
		\begin{tikzpicture}[>=latex, baseline=0.5cm]
		\node[box,align=center] (a) at (0,0) {Studio\\di fattibilità};
		\node[box,align=center] (b) at (3.5,0) {Elicitazione\\e Analisi};
		\node[box,align=center] (c) at (7,0) {Specifica\\dei requisiti};
		\node[box,align=center] (d) at (10.5,0) {Validazione\\dei requisiti};
		
		\node[align=center] (f) at (0,-2) {Rapporto\\ di fattibilità};
		\node[align=center] (g) at (3.5,-2) {Modelli\\ di Sistema};
		\node[align=center] (h) at (7,-2) {Requisiti di\\utente e di sistema};
		
		\draw[->] (a.east) -- (b.west);
		\draw[->] (b.east) -- (c.west);
		\draw[->] (c.east) -- (d.west);
		\draw[->] (a.south) -- (f.north);
		\draw[->] (b.south) -- (g.north);
		\draw[->] (c.south) -- (h.north);
		
		\draw[->] ($ (b.south) -(0.2,0) $) -- ($ (b.south) +(-0.2,-0.5) $) -- ($ (a.south) +(0.2,-0.5) $) --
			($ (a.south) +(0.2,0) $);
			
		\draw[->] ($ (c.south) -(0.2,0) $) -- ($ (c.south) +(-0.2,-0.5) $) -- ($ (b.south) +(0.2,-0.5) $) --
			($ (b.south) +(0.2,0) $);
		
		\end{tikzpicture}
	
	\section{Sviluppo agile}
		\subsection{Introduzione}
		Nel mondo moderno, lo sviluppo rapido e la consegna in breve tempo di un prodotto finito sono i requisiti più importanti per i sistemi software.
		
		Il metodo di sviluppo agile si è sviluppato nei tardi anni 90 e il suo scopo principale era quello di ridurre il tempo di consegna di un prodotto software finito. 
		
		In un sistema agile di norma la progettazione e l'implementazione di un software sono sempre a stretto contatto, e le parti interessate al software sono spesso coinvolte nel processo di sviluppo, per scopi di specifica e validazione del prodotto stesso, che viene consegnato in più versioni (spesso con una documentazione minima, per focalizzare gli sforzi dello sviluppo nella scrittura di codice funzionante).
		
		Lo sviluppo agile del software ruota in generale attorno a 5 principi cardine:
		\begin{itemize}
			\item Coinvolgimento del cliente: sfruttato soprattutto per le sezioni di verifica del prodotto;
			
			\item Consegna incrementale: il cliente specifica i requisiti una porzione alle volta, e la loro realizzazione è inclusa nella consegna del prodotto più vicina;
			
			\item Sfruttamento delle abilità del team;
			
			\item Progettare basandosi sui cambiamenti dei requisiti, quindi sviluppare un prodotto che sia semplice da cambiare;
			
			\item Mantenere la semplicità del prodotto: se possibile lavorare anche attivamente per ridurre la complessità del software sviluppato finora.
		\end{itemize}
	
		\subsection{Extreme programming}
		La tecnica di extreme programming estremizza le condizioni di lavoro per lo sviluppo agile del software, a volte anche facendo build del prodotto diverse volte al giorno, pubblicando release dopo brevissimi periodi di sviluppo e test (circa 2 settimane), e assicurandosi che la release venga pubblicata solo quando tutti i test siano passati.
		
		Le caratteristiche principali dell'extreme programming sono le seguenti:
		\begin{itemize}
			\item Planning dei task incrementale: le caratteristiche da includere nel software sono decise sulla base del tempo che richiedono per essere sviluppate, e sono divise in tasks;
			
			\item Piccole release: una versione con delle funzionalità di base è la prima ad essere rilasciata, successivamente vengono fatte release frequenti e con aggiunte di feature extra in maniera incrementale;
			
			\item Design semplice: il design è spesso progettato in maniera minimale, in modo da concentrare lo sviluppo per soddisfare al massimo i requisiti richiesti;
			
			\item Sviluppo del test necessario per testare una funzionalità prima di implementare la funzionalità stessa;
			
			\item Refactoring: tutti gli sviluppatori eseguono un refactoring del codice ogni volta che sono possibili delle ottimizzazioni, per mantenere il codice più semplice e mantenibile possibile;
			
			\item Pair programming: programmazione di coppia, per verificare ognuno il lavoro dell'altro;
			
			\item Proprietà collettiva: le coppie di sviluppatori lavorano su tutto il software, in modo da non creare zone di codice che solo una coppia sa interpretare e tutti si prendono la responsabilità di tutto il codice;
			
			\item Integrazione continua: ogni volta che una nuova funzionalità è implementata viene immediatamente integrata nel prodotto finito;
			
			\item Ritmo sostenibile: non sono permessi grandi overtime, per non abbassare la qualità del codice;
			
			\item Cliente sempre in loco: un rappresentante del cliente è sempre disponibile al team di sviluppo ed è responsabile per la consegna delle specifiche.
		\end{itemize}
		
		\paragraph{Refactoring} Il refactoring è una procedura (in alcuni punti anche automatizzata) per migliorare la qualità del codice e mantenerlo leggibile e facilmente modificabile, ad esempio riorganizzando la gerarchia delle classi per evitare codice duplicato, tenere un codice pulito per renderlo semplice da capire, usare delle librerie per evitare di sovraccaricare il codice che si scrivere con molte chiamate consecutive.
		
		\paragraph{Test-first} Il metodo test-first è basato sull'idea di sviluppare prima il test della feature che la feature stessa, in questo modo vengono a galla molti chiarimenti sulla funzionalità da implementare. Spesso i test di questo tipo sono vengono eseguiti facendo affidamento su un testing framework, ad esempio JUnit, che aiuta lo sviluppatore nella stesura e nell'esecuzione dei test stessi.
		
	\subsection{Sistema Scrum}
		Il sistema \textit{Scrum} è un metodo di sviluppo basato più sul controllare lo sviluppo iterativo. È contruito su 3 fasi:
		\begin{itemize}
			\item Fase iniziale di pianificazione dove vengono specificati gli obiettivi del software e disegnata l'architettura del sistema;
			\item Fase di sviluppo, costituita da una serie di sprint iterativi che aggiungono sempre nuove feature al sistema;
			
			\item Al termine dello sviluppo, vengono scritti la documentazione e i manuali utente.
		\end{itemize}
		I vantaggi di un sistema Scrum sono dati dal fatto che il prodotto completo per essere sviluppato viene diviso in una serie di sotto-chunk, che vengono risolti man mano dagli sviluppatori durante ogni ciclo di lavoro.
		
	\subsection{Problematiche dello sviluppo agile}
		Le più grandi problematiche dello sviluppo agile sono le seguenti:
		\begin{itemize}
			\item I metodi di lavoro agili sono più adatti alla scrittura di nuovo software piuttosto che alla manutenzione di software precedente, e la maggior parte delle grandi compagnie si affida di più a software datato che viene continuamente aggiornato;
			
			\item I metodi sono concepiti più per lo sviluppo con pochi sviluppatori concentrati in un solo luogo, non per grandi compagnie, per le quali potrebbero risultare dispersivi approcci di questo tipo;
			
			\item Il sistema agile spesso è in conflitto con quello che è l'approccio dell'azienda al sistema di sviluppo del software;
			
			\item Il sistema agile è concentrato maggiormente sulla frequenza delle release che non sulla documentazione, cosa che può rendere problematica la manutenzione di software scritto con questo sistema o software di grandi dimensioni. Per questo motivo si preferisce più che altro usare un approccio plan-driven e agile (una sorta di metodo ibrido), anche per adattarsi a progetti di software con un ciclo di vita lungo (che hanno quindi bisogno di documentazione) o di grandi dimesioni (in quanto richiedono un numero di sviluppatori che può essere sparso per il mondo).
		\end{itemize}
		
	\section{Ingegneria dei requisiti}
	Un requisito è una specifica che può andare dalla descrizione ad alto livello di un servizio fino ad un vincolo che il prodotto deve soddisfare.
	I requisiti si dividono in due macro-categorie:
	\begin{itemize}
		\item Requisiti utente: definiti in linguaggio naturale, specificano i servizi che il sistema deve fornire una volta sviluppato;
		
		\item Requisiti di sistema: sono indicati in un documento ben strutturato, che da una specifica dettagliata delle funzioni del sistema, dei servizi che offre e dei vincoli di funzionamento (di performance, ecc.).
	\end{itemize}

	\subsection{Requisiti funzionali e non funzionali}
	I requisiti si possono suddividere inoltre in altre due grandi categorie:
	\begin{itemize}
		\item Requisiti funzionali: specificano quali servizi il sistema deve offrire, come il sistema dovrebbe reagire di fronte a determinati input, come dovrebbe comportarsi in determinate situazioni
		
		\item Requisiti non funzionali: costituiscono dei vincoli di sistema come ad esempio vincoli di tempo, vincoli di sviluppo ecc.
	\end{itemize}

 	È importante notare che i requisiti funzionali potrebbero anche essere ambigui o venire male interpretati, in tal caso è bene, prima di iniziare lo sviluppo, fare un controllo di completezza e consistenza dei requisiti forniti dall'utente, per evitare errori di progettazione del software.
 	
 	I requisiti funzionali invece non hanno bisogno di particolari tipi di analisi e sono classificati come segue:
 	\begin{itemize}
 		\item Requisiti del prodotto: specificano come il prodotto deve comportarsi;
 		
 		\item Requisiti organizzativi: requisiti derivati da politiche di organizzazione;
 		
 		\item Requisiti esterni: derivano da fattori esterni (legali, di interoperabilità...)
 	\end{itemize}
 
 	\subsection{Processi di ingegneria dei requisiti}
 	Il processo di ingegneria dei requisiti è concentrato su 4 punti, svolti iterativamente:
 	\begin{enumerate}
 		\item Estrazione dei requisiti;
 		\item Analisi dei requisiti;
 		\item Validazione dei requisiti;
 		\item Gestione dei requisiti.
 	\end{enumerate}
	
	\subsubsection{Estrazione dei requisiti}
	È il processo con il quale si determinano i requisiti da implementare:
	\begin{enumerate}
		\item Scoperta dei requisiti: richiede interazione diretta col cliente;
		\item Specifica dei requisiti: stesura dei documenti che specificano i requisiti di sistema e i requisiti utente, in modo che possano essere compresi anche dai clienti;
	\end{enumerate}

	\subsubsection{Validazione dei requisiti}
	È la "dimostrazione" che i requisiti analizzati sono esattamente quello che il cliente vuole dal team di sviluppo. La sezione della validazione è importante, in quanto permette di rilevare gli errori nell'analisi dei requisiti che costerebbero molto tempo per essere risolti in fase di sviluppo.
	
	I punti da tenere sotto controllo sono i seguenti:
	\begin{enumerate}
		\item Validità: verifica che il sistema fornisca le funzioni che il cliente desidera;
		\item Consistenza: controllo di eventuali conflitti di requisiti;
		\item Completezza: verifica che tutte le funzioni desiderate dal cliente siano coperte;
		\item Realismo: verifica che i requisiti specificati siano realizzabili con il budget e le tecnologie disponibili;
		\item Verificabilità: descrizione di metodi per verificare i requisiti.
	\end{enumerate}

	\subsubsection{Gestione dei requisiti}
	Questa parte del processo di ingegnerizzazione dei requisiti consiste nel definire delle politiche di gestione in caso di cambio di requisiti del sistema.
	Il processo di modifica dei requisiti passa attraverso un analisi dei costi di modifica del programma, un'analisi dei delle modifiche da apportare e poi viene avviata la modifica dell'implementazione del prodotto finito.
	
	\section{Pattern di progettazione}
	I pattern di progettazione costituiscono degli schemi di base per progettare alcune porzioni di software con specifiche caratteristiche.
	I principali sono:

	\subsection{Singleton}
	In molte situazioni è necessario garantire l'esistenza di un solo oggetto di una classe.
	
	\noindent
	Il Singleton è usato per assicurare che una classe abbia una sola istanza per tutto il ciclo di vita del software e un unico punto di accesso globale. Le classi Singleton hanno costruttori privati per evitare la possibilità di istanziare più oggetti della stessa classe. Esiste un metodo statico che fa in modo che nessuna istanza venga creata oltre alla prima restituendo un riferimento a quella esistente.
	
	\begin{tikzpicture}[>=latex, baseline=0.5cm]
		\begin{class}[text width=4cm ]{SingletonPatternDemo}{0,0}
			\operation{+ main(): void}
		\end{class}
		\begin{class}[text width=4.5cm ]{SingleObject}{7,0.5}
			\attribute{- instance: SingleObject}
			\operation{- SingleObject}
			\operation{+ getInstance(): singleObject}
			\operation{+ showMessage(): void}
		\end{class}
		
		\draw[->] (SingletonPatternDemo.east) -- ($ (SingleObject.west) + (0,0.08) $) node[above, midway] {asks};
		\draw[->] (SingleObject.south) -- ++(0,-1) -- ++(-4,0) -- ++(0,2.38) -- ++(1.6,0); 
		\node at (5,-3.4) {returns};
	\end{tikzpicture}
	
	\subsection{Observer}
	
	 L'intento dell'Observer (o Publish/Subscribe) è quello di definire una dipendenza uno-a-molti tale che quando un oggetto (\textbf{Subject}) cambia il suo stato, tutti gli altri oggetti (\textbf{Observers}) che ne dipendono vengono notificati automaticamente e aggiornati di conseguenza. In risposta alla notifica gli Observers chiedono al Subject le informazioni necessarie per sincronizzare il proprio stato con quello nuovo del Subject.
	 
	\begin{tikzpicture}[>=latex, scale=0.8, every node/.style={scale=0.8}]
		\begin{class}[text width=4cm ]{ObserverPatternDemo}{0,3}
			\operation{+ main(): void}
		\end{class}

		\begin{abstractclass}[text width=3cm ]{Observer}{-1,0}
			\attribute{+ subject: Subject}
			\operation{+ update(): void}
		\end{abstractclass}
		\begin{class}[text width=3cm ]{BinaryObserver}{-5,-3}
			\inherit{Observer}
			\attribute{+ subject: Subject}
			\operation{+ update(): void}
		\end{class}
		\begin{class}[text width=3cm ]{OctalObserver}{-1,-3}
			\inherit{Observer}
			\attribute{+ subject: Subject}
			\operation{+ update(): void}
		\end{class}
		\begin{class}[text width=3cm ]{HexaObserver}{3,-3}
			\inherit{Observer}
			\attribute{+ subject: Subject}
			\operation{+ update(): void}
		\end{class}
		\begin{class}[text width=4.5cm ]{Subject}{8,0}
			\attribute{- observers: List<Observer>}
			\attribute{-state: int}
			\operation{+ getState: int}
			\operation{+ setState: void}
			\operation{+ notifyAllObservers: void}
		\end{class}
		\draw[thick] (-7,0.5) rectangle (11,-5);
		
		\draw[->] (ObserverPatternDemo.south) -- (0,0.5) node[right, midway] {asks};
		\draw[->] (Subject.west) -- (Observer.east) node[above, midway] {uses};
	\end{tikzpicture}
	
	\subsection{Data Transfer Object}
	Quando l'invocazione tra oggetti è \textbf{remota} è più conveniente permettere al client di gestire molti valori in un unica operazione piuttosto che avere invocazioni distinte.
	
	\noindent
	Il pattern DTO è usato quindi per trasferire dati tra un client e un server e permette di gestire più oggetti con una singola invocazione piuttosto che singolarmente. L'oggetto DTO contiene un sottoinsieme dei dati del BusinessObject remoto, non ha metodi comportamentali e permette l'accesso diretto ai dati senza fare get/set.
	
	\begin{tikzpicture}[>=latex, baseline=0.5cm, scale=0.9, every node/.style={scale=0.9}]
		\begin{class}[text width=3.5cm ]{DataTransferObject}{0,0}
			\operation{}
		\end{class}
		\begin{class}[text width=10cm ]{BusinessObject}{9,0}
			\operation{+ getDataTransferObject(): DataTransferObject}
			\operation{+ setDataTransferObject(in aDTO: DataTransferObject): void}
		\end{class}
		\begin{class}[text width=2cm ]{Client}{0,-2.5}
			\operation{}
		\end{class}
		\draw[->] (Client.north) -- (DataTransferObject.south) node[midway, right] {uses};
		\draw[->] (BusinessObject.west) -- (DataTransferObject.east) node[midway, above] {uses};
	\end{tikzpicture}
	
	\subsection{Adapter}
	L'adapter permette di fare da tramite tra due interfacce incompatibili. Converte un interfaccia di una classe in un'altra richiesta dal client, consentendo a diverse classi di operare insieme quando altrimenti ciò non sarebbe possibile. La classe Adapter implementa l'interfaccia, estende la classe esistente e ridefinisce il suo metodo chiamando quello richiesto.
	
	\begin{tikzpicture}[>=latex, baseline=0.25cm, scale=0.9, every node/.style={scale=0.9}]
		\begin{class}[text width=2cm ]{Client}{0,0}
			\operation{}
		\end{class}
		\begin{interface}[text width=3.5cm ]{ThoughtfulInterface}{0,-2}
			\operation{+ service()}
		\end{interface}
		\begin{class}[text width=3cm ]{ExistingClass}{10,-2}
			\operation{+ usefulMethod()}
		\end{class}
		\begin{class}[text width=2.5cm ]{Adapter}{5,-2}
			\implement{ThoughtfulInterface}
			\inherit{ExistingClass}
			\operation{+ service()}
		\end{class}
		
		\draw[dashed, ->] (Client.south) -- (ThoughtfulInterface.north) node[right, midway] {uses};
	\end{tikzpicture}
	
	\subsection{Template}
	 Il pattern Template consiste nel definire la struttura di un algoritmo in una superclasse delegando alcuni passi dell'algoritmo a una o più sottoclassi. Le sottoclassi ridefiniscono alcuni passi dell'algoritmo senza dover implementare la struttura dell'algoritmo stesso (\textit{hook}). \\
	
	\begin{tikzpicture}[>=latex]
		\begin{class}[text width=3cm ]{AbstractClass}{5,0}
			\operation{primitiveOp1()}
			\operation{primitiveOp2()}
		\end{class}
		\umlnote[text width=3cm, align=left ] (note) at (10,0) {\\...\\
			if (...)\\
			then primitiveOp1()\\
			else primitive Op2()\\
			...};
		\begin{class}[text width=3cm ]{ConcreteClass}{0,0}
			\inherit{AbstractClass}
			\operation{primitiveOp1()}
			\operation{primitiveOp2()}
		\end{class}
		\draw[dashed] (note.west) -- (AbstractClass.east);
		
	\end{tikzpicture}
	
	\subsection{Decorator}
	Il pattern Decorator permette di aggiungere funzionalità ad un oggetto già esistente senza modificarne le proprietà o la sua struttura. Si crea una classe Decorator che fa da wrapper alla classe originale e aggiunge funzionalità mantenendo i metodi della classe intatti.
	
	\begin{tikzpicture}[>=latex, baseline=0.25cm, scale=0.7, every node/.style={scale=0.7}]
		\begin{interface}[text width=2.5cm ]{Shape}{0,0}
			\operation{+ draw(): void}
		\end{interface}
		\begin{class}[text width=2.5cm ]{Circle}{-2,-3}
			\inherit{Shape}
			\operation{+ draw(): void}
		\end{class}
		\begin{class}[text width=2.5cm ]{Rectangle}{2,-3}
			\inherit{Shape}
			\operation{+ draw(): void}
		\end{class}
		\begin{class}[text width=3.5cm ]{ShapeDecorator}{7,0}
			\attribute{+ shape(): Shape}
			\operation{+ ShapeDecorator()}
			\operation{+ draw(): void}
		\end{class}
		\begin{class}[text width=4cm ]{RedShapeDecorator}{7,-4}
			\inherit{ShapeDecorator}
			\attribute{+ shape(): Shape}
			\operation{+ RedShapeDecorator()}
			\operation{+ draw(): void}
		\end{class}
		\begin{class}[text width=2cm ]{Client}{12,0}
			\operation{+ main(): void}
		\end{class}
		\draw[->] (ShapeDecorator.west) -- (Shape.east) node[midway, above] {decorates};
		\draw[->] (Client.west) -- (ShapeDecorator.east) node[midway, above] {asks};
	\end{tikzpicture}
	
	\subsection{Facade}
	Il pattern Facade propone dei metodi che nascondono al client la complessità del sistema, poi la classe maschera andrà a chiamare i metodi più complessi all'interno del sistema.
	
	\subsection{Factory}
	Consiste nel creare un oggetto senza esporre la logica della creazione al client e si riferisce all'oggetto nuovo creato utilizzando un interfaccia comune.
	
	\begin{tikzpicture}[>=latex, baseline=0.5cm, scale=0.7, every node/.style={scale=0.7}]
		\begin{interface}[text width=3.5cm]{MultiColumnListbox}{2,0}
			\operation{}	
		\end{interface}
		\begin{class}[text width=2cm]{CartUI}{-1,-3}
			\inherit{MultiColumnListbox}
			\operation{}	
		\end{class}
		\begin{class}[text width=2cm]{CatalogueUI}{2,-3}
			\inherit{MultiColumnListbox}
			\operation{}	
		\end{class}
		\begin{class}[text width=2cm]{SellUI}{5,-3}
			\inherit{MultiColumnListbox}
			\operation{}	
		\end{class}
		\begin{class}[text width=2cm]{Client}{13,-4}
			\operation{}	
		\end{class}
		\begin{class}[text width=8cm]{MultiColumnListFactory}{13,0.5}
			\operation{+ getMultiColumnListbox(): MultiColumnListbox}
			\attribute{- CartUI: MultiColumnListbox}
			\attribute{- CatalogueUI: MultiColumnListbox}
			\attribute{- SellUI: MultiColumnListbox}
		\end{class}
		\draw[thick] (-2.5,0.5) rectangle (7,-4.5);
		\draw[->] (MultiColumnListFactory.west) -- (7,-0.75) node[midway, above] {creates};
		\draw[->] (Client.north) -- (MultiColumnListFactory.south) node[midway, right] {asks};
	\end{tikzpicture}
	
	\subsection{Iterator}
	Questo pattern è usato per scorrere sequenzialmente gli elementi di una collezione senza dover conoscere la sua rappresentazione sottostante.
	
	\subsection{Abstract Factory} 
	Il pattern abstract factory lavora attorno ad una super-factory che crea altre factory. È chiamato anche factory di factory. L'interfaccia crea una factory di oggetti senza specificare esplicitamente le loro classi.
	
	\subsection{Proxy}
	Una classe proxy rappresenta le funzionalità di un'altra classe. Creo l'oggetto originale che si interfaccia al mondo esterno.
	
	\begin{tikzpicture}[>=latex, baseline=0.25cm, scale=0.7, every node/.style={scale=0.7}]
		\begin{interface}[text width=3.5cm]{Image}{2,0}
			\operation{+ display(): void}	
		\end{interface}
		\begin{class}[text width=4cm]{RealImage}{-1,-3}
			\inherit{Image}
			\operation{+ RealImage()}
			\operation{+ display(): void}	
		\end{class}
		\begin{class}[text width=4cm]{ProxyImage}{5,-3}
			\inherit{Image}
			\attribute{+ realImage: RealImage}
			\operation{+ ProxyImage()}
			\operation{+ display(): void}	
		\end{class}
		\begin{class}[text width=3cm]{Client}{12,-3}
			\operation{+ main(): void}	
		\end{class}
	
		\draw[->] (Client.west) -- (ProxyImage.east) node[midway, above] {asks};
	\end{tikzpicture}
	\newpage
	\section{Credits}
	\begin{itemize}
		\item Davide Bianchi (\verb|davideb1912@gmail.com|)
		\item Matteo Danzi (\verb|matteodanziguitarman@hotmail.it|)
	\end{itemize}
	
	
\end{document}